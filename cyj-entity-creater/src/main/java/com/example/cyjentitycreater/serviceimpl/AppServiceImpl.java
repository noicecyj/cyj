package com.example.cyjentitycreater.serviceimpl;

import com.example.cyjcommon.utils.CommonUtils;
import com.example.cyjentitycreater.entity.AppServicePO;
import com.example.cyjentitycreater.entity.DictionaryDTO;
import com.example.cyjentitycreater.service.DictionaryApiService;
import com.example.cyjentitycreater.utils.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;

import static com.example.cyjentitycreater.utils.BeanUtils.serviceFileName;

/**
 * @author 曹元杰
 * @version 1.0
 * @date 2020/12/21 14:46
 */
@Component
public class AppServiceImpl extends BaseService {

    private AppServiceServiceImpl appServiceService;

    private DictionaryApiService dictionaryApiService;

    @Autowired
    public void setAppServiceService(AppServiceServiceImpl appServiceService) {
        this.appServiceService = appServiceService;
    }

    @Autowired
    public void setDictionaryApiService(DictionaryApiService dictionaryApiService) {
        this.dictionaryApiService = dictionaryApiService;
    }

    public void createJavaFile(AppServicePO po) throws IOException {
        List<DictionaryDTO> pos = dictionaryApiService.findCatalogByValue("FILE_PATH");
        HashMap<String, DictionaryDTO> mapPo = CommonUtils.listToMap(pos, "dictionaryName");
        appGenerate(po);
    }

    public String[] appGenerate(AppServicePO po) {
        String appName = BeanUtils.underline2Camel2(po.getAppName());
        String AppName = BeanUtils.captureName(BeanUtils.underline2Camel2(po.getAppName()));
        StringBuilder sb = new StringBuilder();
        sb.append("package com.example.").append(appName).append(";\r\n");
        sb.append("\r\n");
        sb.append("import org.springframework.boot.SpringApplication;\r\n");
        sb.append("import org.springframework.boot.autoconfigure.SpringBootApplication;\r\n");
        sb.append("import org.springframework.cloud.netflix.eureka.EnableEurekaClient;\r\n");
        sb.append("import org.springframework.cloud.openfeign.EnableFeignClients;\r\n");
        sb.append("\r\n");
        generateAuthor(sb);
        sb.append("@SpringBootApplication\r\n");
        sb.append("@EnableEurekaClient\r\n");
        sb.append("@EnableFeignClients\r\n");
        sb.append("public class ").append(AppName).append("Application {\r\n");
        sb.append("\r\n");
        sb.append("    public static void main(String[] args) {\r\n");
        sb.append("        SpringApplication.run(").append(AppName).append("Application.class, args);\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("}\r\n");
        String serviceFileData = sb.toString();
        return new String[]{serviceFileData, serviceFileName(po)};
    }

    public String[] appLogGenerate(AppServicePO po) {
        String appName = BeanUtils.underline2Camel2(po.getAppName());
        String AppName = BeanUtils.captureName(BeanUtils.underline2Camel2(po.getAppName()));
        StringBuilder sb = new StringBuilder();
        sb.append("package com.example.cyjquery.config;\r\n");
        sb.append("\r\n");
        sb.append("import ch.qos.logback.classic.spi.*;\r\n");
        sb.append("import ch.qos.logback.core.CoreConstants;\r\n");
        sb.append("import ch.qos.logback.core.db.DBAppenderBase;\r\n");
        sb.append("import ch.qos.logback.core.db.DBHelper;\r\n");
        sb.append("import com.example.cyjcommon.config.SqlBuilder;\r\n");
        sb.append("\r\n");
        sb.append("import java.lang.reflect.Method;\r\n");
        sb.append("import java.sql.Connection;\r\n");
        sb.append("import java.sql.PreparedStatement;\r\n");
        sb.append("import java.sql.SQLException;\r\n");
        sb.append("import java.text.SimpleDateFormat;\r\n");
        sb.append("import java.util.*;\r\n");
        sb.append("\r\n");
        sb.append("import static ch.qos.logback.core.db.DBHelper.closeStatement;\r\n");
        sb.append("\r\n");
        sb.append("/**\r\n");
        sb.append(" * @author 曹元杰\r\n");
        sb.append(" * @version 1.0\r\n");
        sb.append(" * @date 2020/1/21 14:46\r\n");
        sb.append(" */\r\n");
        sb.append("public class ServerLogAppender extends DBAppenderBase<ILoggingEvent> {\r\n");
        sb.append("\r\n");
        sb.append("    protected String insertPropertiesSql;\r\n");
        sb.append("    protected String insertExceptionSql;\r\n");
        sb.append("    protected static final Method GET_GENERATED_KEYS_METHOD;\r\n");
        sb.append("\r\n");
        sb.append("    protected String insertSql;\r\n");
        sb.append("    /**\r\n");
        sb.append("     * id\r\n");
        sb.append("     */\r\n");
        sb.append("    static final int UUID_INDEX = 1;\r\n");
        sb.append("    /**\r\n");
        sb.append("     * 应用的端口\r\n");
        sb.append("     */\r\n");
        sb.append("    static final int APP_INDEX = 2;\r\n");
        sb.append("    /**\r\n");
        sb.append("     * 类名\r\n");
        sb.append("     */\r\n");
        sb.append("    static final int CLASS_INDEX = 3;\r\n");
        sb.append("    /**\r\n");
        sb.append("     * 路径\r\n");
        sb.append("     */\r\n");
        sb.append("    static final int CLASSPATH_INDEX = 4;\r\n");
        sb.append("    /**\r\n");
        sb.append("     * 方法名\r\n");
        sb.append("     */\r\n");
        sb.append("    static final int METHOD_INDEX = 5;\r\n");
        sb.append("    /**\r\n");
        sb.append("     * 线程名\r\n");
        sb.append("     */\r\n");
        sb.append("    static final int THREADNAME_INDEX = 6;\r\n");
        sb.append("    /**\r\n");
        sb.append("     * 信息级别\r\n");
        sb.append("     */\r\n");
        sb.append("    static final int MSGLEVEL_INDEX = 7;\r\n");
        sb.append("    /**\r\n");
        sb.append("     * 日志信息\r\n");
        sb.append("     */\r\n");
        sb.append("    static final int MSG_INDEX = 8;\r\n");
        sb.append("    /**\r\n");
        sb.append("     * 创建时间\r\n");
        sb.append("     */\r\n");
        sb.append("    static final int CREATEDATE_INDEX = 9;\r\n");
        sb.append("\r\n");
        sb.append("    static final StackTraceElement EMPTY_CALLER_DATA = CallerData.naInstance();\r\n");
        sb.append("\r\n");
        sb.append("    static {\r\n");
        sb.append("        // PreparedStatement.getGeneratedKeys() method was added in JDK 1.4\r\n");
        sb.append("        Method getGeneratedKeysMethod;\r\n");
        sb.append("        try {\r\n");
        sb.append("            // the\r\n");
        sb.append("            getGeneratedKeysMethod = PreparedStatement.class.getMethod(\"getGeneratedKeys\");\r\n");
        sb.append("        } catch (Exception ex) {\r\n");
        sb.append("            getGeneratedKeysMethod = null;\r\n");
        sb.append("        }\r\n");
        sb.append("        GET_GENERATED_KEYS_METHOD = getGeneratedKeysMethod;\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    @Override\r\n");
        sb.append("    public void start() {\r\n");
        sb.append("        insertSql = SqlBuilder.buildInsertSql();\r\n");
        sb.append("        super.start();\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    @Override\r\n");
        sb.append("    protected Method getGeneratedKeysMethod() {\r\n");
        sb.append("        return GET_GENERATED_KEYS_METHOD;\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    @Override\r\n");
        sb.append("    protected String getInsertSQL() {\r\n");
        sb.append("        return insertSql;\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    @Override\r\n");
        sb.append("    protected void subAppend(ILoggingEvent event, Connection connection, PreparedStatement insertStatement) throws Throwable {\r\n");
        sb.append("        bindLoggingMyInfoWithPreparedStatement(insertStatement);\r\n");
        sb.append("        bindLoggingEventWithInsertStatement(insertStatement, event);\r\n");
        sb.append("        // This is expensive... should we do it every time?\r\n");
        sb.append("        bindCallerDataWithPreparedStatement(insertStatement, event.getCallerData());\r\n");
        sb.append("        int updateCount = insertStatement.executeUpdate();\r\n");
        sb.append("        if (updateCount != 1) {\r\n");
        sb.append("            addWarn(\"Failed to insert loggingEvent\");\r\n");
        sb.append("        }\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    @Override\r\n");
        sb.append("    protected void secondarySubAppend(ILoggingEvent eventObject, Connection connection, long eventId) throws Throwable {\r\n");
        sb.append("        Map<String, String> mergedMap = mergePropertyMaps(eventObject);\r\n");
        sb.append("        insertProperties(mergedMap, connection, eventId);\r\n");
        sb.append("        if (eventObject.getThrowableProxy() != null) {\r\n");
        sb.append("            insertThrowable(eventObject.getThrowableProxy(), connection, eventId);\r\n");
        sb.append("        }\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    Map<String, String> mergePropertyMaps(ILoggingEvent event) {\r\n");
        sb.append("        Map<String, String> mergedMap = new HashMap<>(16);\r\n");
        sb.append("        // we add the context properties first, then the event properties, since\r\n");
        sb.append("        // we consider that event-specific properties should have priority over\r\n");
        sb.append("        // context-wide properties.\r\n");
        sb.append("        Map<String, String> loggerContextMap = event.getLoggerContextVO().getPropertyMap();\r\n");
        sb.append("        Map<String, String> mdcMap = event.getMDCPropertyMap();\r\n");
        sb.append("        if (loggerContextMap != null) {\r\n");
        sb.append("            mergedMap.putAll(loggerContextMap);\r\n");
        sb.append("        }\r\n");
        sb.append("        if (mdcMap != null) {\r\n");
        sb.append("            mergedMap.putAll(mdcMap);\r\n");
        sb.append("        }\r\n");
        sb.append("        return mergedMap;\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    protected void insertProperties(Map<String, String> mergedMap, Connection connection, long eventId) throws SQLException {\r\n");
        sb.append("        Set<String> propertiesKeys = mergedMap.keySet();\r\n");
        sb.append("        if (propertiesKeys.size() > 0) {\r\n");
        sb.append("            PreparedStatement insertPropertiesStatement = null;\r\n");
        sb.append("            try {\r\n");
        sb.append("                insertPropertiesStatement = connection.prepareStatement(insertPropertiesSql);\r\n");
        sb.append("                for (String key : propertiesKeys) {\r\n");
        sb.append("                    String value = mergedMap.get(key);\r\n");
        sb.append("                    insertPropertiesStatement.setLong(1, eventId);\r\n");
        sb.append("                    insertPropertiesStatement.setString(2, key);\r\n");
        sb.append("                    insertPropertiesStatement.setString(3, value);\r\n");
        sb.append("                    if (cnxSupportsBatchUpdates) {\r\n");
        sb.append("                        insertPropertiesStatement.addBatch();\r\n");
        sb.append("                    } else {\r\n");
        sb.append("                        insertPropertiesStatement.execute();\r\n");
        sb.append("                    }\r\n");
        sb.append("                }\r\n");
        sb.append("                if (cnxSupportsBatchUpdates) {\r\n");
        sb.append("                    insertPropertiesStatement.executeBatch();\r\n");
        sb.append("                }\r\n");
        sb.append("            } finally {\r\n");
        sb.append("                closeStatement(insertPropertiesStatement);\r\n");
        sb.append("            }\r\n");
        sb.append("        }\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    protected void insertThrowable(IThrowableProxy tp, Connection connection, long eventId) throws SQLException {\r\n");
        sb.append("        PreparedStatement exceptionStatement = null;\r\n");
        sb.append("        try {\r\n");
        sb.append("            exceptionStatement = connection.prepareStatement(insertExceptionSql);\r\n");
        sb.append("            short baseIndex = 0;\r\n");
        sb.append("            while (tp != null) {\r\n");
        sb.append("                baseIndex = buildExceptionStatement(tp, baseIndex, exceptionStatement, eventId);\r\n");
        sb.append("                tp = tp.getCause();\r\n");
        sb.append("            }\r\n");
        sb.append("            if (cnxSupportsBatchUpdates) {\r\n");
        sb.append("                exceptionStatement.executeBatch();\r\n");
        sb.append("            }\r\n");
        sb.append("        } finally {\r\n");
        sb.append("            closeStatement(exceptionStatement);\r\n");
        sb.append("        }\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    void bindLoggingMyInfoWithPreparedStatement(PreparedStatement stmt) throws SQLException {\r\n");
        sb.append("        String appPort = \"8070\";\r\n");
        sb.append("        stmt.setString(APP_INDEX, appPort);\r\n");
        sb.append("        Date day = new Date();\r\n");
        sb.append("        SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n");
        sb.append("        stmt.setString(CREATEDATE_INDEX, df.format(day));r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    void bindLoggingEventWithInsertStatement(PreparedStatement stmt, ILoggingEvent event) throws SQLException {\r\n");
        sb.append("        stmt.setString(UUID_INDEX, String.valueOf(UUID.randomUUID()));\r\n");
        sb.append("        stmt.setString(MSG_INDEX, event.getFormattedMessage());\r\n");
        sb.append("        stmt.setString(MSGLEVEL_INDEX, event.getLevel().toString());\r\n");
        sb.append("        stmt.setString(THREADNAME_INDEX, event.getThreadName());\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    void bindCallerDataWithPreparedStatement(PreparedStatement stmt, StackTraceElement[] callerDataArray) throws SQLException {\r\n");
        sb.append("        StackTraceElement caller = extractFirstCaller(callerDataArray);\r\n");
        sb.append("        stmt.setString(CLASS_INDEX, caller.getFileName());\r\n");
        sb.append("        stmt.setString(CLASSPATH_INDEX, caller.getClassName());\r\n");
        sb.append("        stmt.setString(METHOD_INDEX, caller.getMethodName());\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    private StackTraceElement extractFirstCaller(StackTraceElement[] callerDataArray) {\r\n");
        sb.append("        StackTraceElement caller = EMPTY_CALLER_DATA;\r\n");
        sb.append("        if (hasAtLeastOneNonNullElement(callerDataArray)) {\r\n");
        sb.append("            caller = callerDataArray[0];\r\n");
        sb.append("        }\r\n");
        sb.append("        return caller;\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    private boolean hasAtLeastOneNonNullElement(StackTraceElement[] callerDataArray) {\r\n");
        sb.append("        return callerDataArray != null && callerDataArray.length > 0 && callerDataArray[0] != null;\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    @Override\r\n");
        sb.append("    public void append(ILoggingEvent eventObject) {\r\n");
        sb.append("        Connection connection = null;\r\n");
        sb.append("        try {\r\n");
        sb.append("            connection = connectionSource.getConnection();\r\n");
        sb.append("            connection.setAutoCommit(false);\r\n");
        sb.append("            PreparedStatement insertStatement;\r\n");
        sb.append("            insertStatement = connection.prepareStatement(getInsertSQL());\r\n");
        sb.append("            // inserting an event and getting the result must be exclusive\r\n");
        sb.append("            synchronized (this) {\r\n");
        sb.append("                subAppend(eventObject, connection, insertStatement);\r\n");
        sb.append("            }\r\n");
        sb.append("            // we no longer need the insertStatement\r\n");
        sb.append("            if (insertStatement != null) {\r\n");
        sb.append("                insertStatement.close();\r\n");
        sb.append("            }\r\n");
        sb.append("            connection.commit();\r\n");
        sb.append("        } catch (Throwable sqle) {\r\n");
        sb.append("            addError(\"problem appending event\", sqle);\r\n");
        sb.append("        } finally {\r\n");
        sb.append("            DBHelper.closeConnection(connection);\r\n");
        sb.append("        }\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    short buildExceptionStatement(IThrowableProxy tp, short baseIndex, PreparedStatement insertExceptionStatement, long eventId) throws SQLException {\r\n");
        sb.append("        StringBuilder buf = new StringBuilder();\r\n");
        sb.append("        ThrowableProxyUtil.subjoinFirstLine(buf, tp);\r\n");
        sb.append("        updateExceptionStatement(insertExceptionStatement, buf.toString(), baseIndex++, eventId);\r\n");
        sb.append("        int commonFrames = tp.getCommonFrames();\r\n");
        sb.append("        StackTraceElementProxy[] stepArray = tp.getStackTraceElementProxyArray();\r\n");
        sb.append("        for (int i = 0; i < stepArray.length - commonFrames; i++) {\r\n");
        sb.append("            StringBuilder sb = new StringBuilder();\r\n");
        sb.append("            sb.append(CoreConstants.TAB);\r\n");
        sb.append("            ThrowableProxyUtil.subjoinSTEP(sb, stepArray[i]);\r\n");
        sb.append("            updateExceptionStatement(insertExceptionStatement, sb.toString(), baseIndex++, eventId);\r\n");
        sb.append("        }\r\n");
        sb.append("        if (commonFrames > 0) {\r\n");
        sb.append("            updateExceptionStatement(insertExceptionStatement, CoreConstants.TAB + \"... \" + commonFrames + \" common frames omitted\", baseIndex++, eventId);\r\n");
        sb.append("        }\r\n");
        sb.append("        return baseIndex;\r\n");
        sb.append("    }\r\n");
        sb.append("\r\n");
        sb.append("    void updateExceptionStatement(PreparedStatement exceptionStatement, String txt, short i, long eventId) throws SQLException {\r\n");
        sb.append("        exceptionStatement.setLong(1, eventId);\r\n");
        sb.append("        exceptionStatement.setShort(2, i);\r\n");
        sb.append("        exceptionStatement.setString(3, txt);\r\n");
        sb.append("        if (cnxSupportsBatchUpdates) {\r\n");
        sb.append("            exceptionStatement.addBatch();\r\n");
        sb.append("        } else {\r\n");
        sb.append("            exceptionStatement.execute();\r\n");
        sb.append("        }\r\n");
        sb.append("    }\r\n");
        sb.append("}\r\n");
        String serviceFileData = sb.toString();
        return new String[]{serviceFileData, serviceFileName(po)};
    }
}
